- godot will attempt to load a .image file. Since squeak images share that extension,
  we need to put plugin files including the squeak file into a folder with a .gdignore file
- https://godotengine.org/article/look-gdnative-architecture
- godot does **not** load dependencies for you, normal rpath rules still apply

- Problem: How to call init_squeak_callbacks() from inside Squeak via FFI?
  - The squeak method that performs this call uses the pragma `<apicall: void init_squeak_callbacks()>`
  - If the class containing the method has the module 'sqplugin', the FFI call fails with 'Error: External module not found'.
    This makes sense because there is no libsqplugin.so that it could load.
    The shared library is already loaded anyway and shouldn't be loaded again.
  - If the class has the module '' (empty string) which triggers internal function resolution, the FFI call fails with 'Error: Unable to find function address'. So internal resolution has failed as well.
    - Excursion: How Smalltalk's internal function resolution works
      The VM will first try to get the module handle for the given module name.
      If the module name is either NULL or an empty string, it will resolve to the module handle of the main program.
      It will then try to find the internal function for that module.
      The function it uses for this is findInternalFunctionIn(char *functionName, char *pluginName, ...)
      For that purpose, there exists an (apparently autogenerated) file containing an array with an element for each internal module.
      Each element is another array with all the exported functions of its respective module.
      The VM will look through the items of the module with the matching name (in the case of the vm module, an empty string) and return the one that matches, or fail.
    - Aside: The VM entrypoint for FFI calls is primitiveCallout()
  - Possible Solutions:
    - Write a plugin for the VM that has a function that performs the callback initialization.
      That function would likely have to load the init_squeak_callbacks symbol with dlsym (is this possible?)
    - Write a shared library that is loaded by both sqPlugin and the VM that handles the initialization.
      This works because calling dlopen multiple times on the same library will always return the same handle.
      - wait -- why can't I just load sqPlugin from within Smalltalk a second time?
        - turns out, I can

- icons for classes and methods are determined in ToolIcons

- PluginScriptLanguage does not implement make_template. Due to further implementation details, this means that PluginScript scripts are not automatically loaded when they are created
- ResourceFormatSaverPluginScript does not reload scripts on save. There is an option for that, but it is only respected by the gdscript saver
  https://github.com/godotengine/godot/issues/19653
  - solution a: modify godot source
  - solution b: abuse the template generation function for that

- godot might allow property hinting, see godot_nativescript_register_property or the script manifest

- godot_variant_call returns a godot_variant on the stack. who owns it? do I need to destroy it?

- creating an array of pointers may require allocating the contents externally. see FFI-Tests>>test22ArrayForVoidPointers

- if a script file is deleted, should the corresponding class be removed as well? or only the mapping between the class and the file?

- problem: if a method is called on a godot object that has a smalltalk script attached, it attempts to call all functions in the smalltalk script, even the ones that are defined by the engine. the latter ones should not be forwarded to squeak but instead be handled as if no script was attached
  - easy solution: set the error code in the function call to CALL_ERROR_INVALID_METHOD
    this will make godot perform the method on the underlying object
    - this means that we should ONLY perform user defined messages (ie defined in a subclass of an generated godot api class) within squeak
    - a check whether this function is user defined can be relatively easily implemented on the squeak side, but should eventually be done on the C side to prevent unnecessary FFI calls

- Fun problem: The messages arrive in a queue and are handled one by one and one at a time by a message listener.
  This is fine as long as only one message needs to be handled at a time.
  However, in some circumstances it might be possible that this is not the case, with a deadlock being the result.
  For example:
  A Squeak script calls a function on a Godot object which in turn triggers a signal.
  One of the receivers of the signal is another Squeak script or is a function that calls a Squeak script, meaning that the Squeak VM must now handle another message.
  But because the VM is already processing the old message that triggered the new message, it cannot handle the new message.
  And since Godot is waiting for the new message to be handled, it will never complete the first function call on which Squeak is waiting.
  Now Godot and Squeak are waiting for each other to complete their requests and we have a good ol' fashioned deadlock.
  - This would never happen if we had proper threaded FFI Callbacks >:(
  - The obvious solution is to have multiple listener active. I see two ways to do this
    - Have a pool of listeners. If the last available listeners starts to handle a message, it spawns a new listener
      This might have an impact on performance if a lot of listeners compete for processing time, since they all wait busily
    - Have a "listener stack", where each listener has a child listener which it activates when it starts to process a new message and deactivates when it stops
      This would circumvent the potential performance issue of the first solution, but will likely be some synchronization issues, especially if Godot can send messages from multiple threads.
  - NOTE: Godot signals are handled synchronously unless CONNECT_DEFERRED is specified

- on Godot multithreading: https://godotengine.org/article/why-does-godot-use-servers-and-rids

- ugly: functions that are called from squeak which are neither defined in squeak nor part of the godot api (eg defined in gdscript) are red in squeak

- most of the builtin godot types can be generated, because it seems that variants that contain them correctly work with call()
  - hmm, so it seems that trying to do something like myVectorTwo.call("length") fails.
    it looks like the function lookup fails, but maybe i'm missing something?
  - so previously I assumed that `myVectorTwo.call("length")` would call call_ptr() with "length" as the method name.
    however, it actually calls it with "call" as the method name, with "length" being an argument.
    The error message says something along of "Vector2 does not have a length method", which is misleading and likely a bug

- Godot always triggers two script reloads if a pluginscript source file changes on disc.
  Once of them in ScriptEditor _reloadsScripts, once in the PluginScript resource loader, called within the same function.

- spinlock vs semaphore:
  https://stackoverflow.com/questions/195853/spinlock-versus-semaphore
  https://stackoverflow.com/questions/5869825/when-should-one-use-a-spinlock-instead-of-mutex
  semaphores might behave like a spinlock for short operations? if that is true, that would be very benificial for us

- I'm writing down my thoughts on bidirectional communication here because I forgot them once and tried to do weird stuff
  - Problem: Sometimes, the handling of a request from Godot leads to Squeak requesting something from Godot and vice versa.
    Both threads have to be ready to handle a request at all times and cannot freeze without potentially causing a deadlock.
  - Solution:
    1. There are only two threads involved in handling a request: Godot (more precisely its game logic thread) and Squeak
    2. The handling of a request may entail multiple other requests. Let's call this a message exchange.
    3. Only Godot will ever trigger a message exchange.
    4. A request starts with some kind of signal that a message is ready and ends by signalling that the request was processed.
    5. Optionally, between request start and end the handling thread may require the other thread to do something. In that case, it sends a request to it.
    6. From this follows that only one thread is active at a time. The other can effectively sleep.
    7. However, if no request is handled at all, neither thread may sleep so neither Godot nor Squeak freeze.
    8. When 5 occurs, we are guaranteed to have a stack frame handling the previous request.
    9. Because of 6, synchronization mechanisms between threads are not required per message but only per message exchange.
    10. From 1 follows that there can only be one message exchange at a time, and thus synchronization mechanisms can be global.

    Process:
      Starting out:
      1. Starting out Godot does its own thing and Squeak busy waits for a message in a place that is synchronized between the threads.
      2. When Godot wants Squeak to do something, it places a message for Squeak and waits for incoming messages.
      3. Squeak takes the message and processes it.

      Processing (same for both threads):
      1. When a thread receives a message, it processes it.
      2. If it needs the other side to do something, it places a message, signals the other side, and waits for a result.
      3. If it is done processesing, it places the result as a message and signals the other side.
